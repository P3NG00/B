public sealed class Solitaire : Option
{
    private const int PILESPLAY = 7;
    private const int PILESFINAL = 4;

    private readonly Deck[] pilesPlay = new Deck[PILESPLAY];
    private readonly Deck[] pilesFinal = new Deck[PILESFINAL];
    private Deck deck;
    private Deck hand;
    private Stage stage = Stage.MainMenu;

    public sealed override void Loop()
    {
        switch (this.stage)
        {
            case Stage.MainMenu:
                {
                    Console.Clear();
                    Util.SetConsoleSize(20, 7);
                    InputOptionBuilder.Create("Solitaire")
                        .AddAction('1', () => this.stage = Stage.GameSetup, "New Game")
                        .AddSpacer()
                        .AddAction('0', () => this.Running = false, "Back")
                        .Request();
                }
                break;

            case Stage.GameSetup:
                {
                    for (int i = 0; i < this.pilesPlay.Length; i++)
                    {
                        this.pilesPlay[i] = new Deck();
                    }

                    this.deck = Deck.CreateShuffledDeck();
                    this.hand = new Deck();

                    // TODO test this by printing out piles, format console window
                    for (int i = 0; i < PILESPLAY; i++)
                    {
                        for (int j = i; j < PILESPLAY; j++)
                        {
                            this.deck.DealTo(this.pilesPlay[j]);
                        }
                    }

                    this.stage = Stage.Game;
                }
                break;

            case Stage.Game:
                {
                    /*

                    sample screen

                    A B C D = top card of final play piles
                    -------------

                      A? B? C? D?

                      1) <pile 1>
                      2) <pile 2>
                      3) <pile 3>
                      4) <pile 4>
                      5) <pile 5>
                      6) <pile 6>
                      7) <pile 7>

                      ENTER) draw 3 cards
                      TODO need way to access final piles

                    */

                    Console.Clear();
                    Util.SetConsoleSize(30, 15); // TODO adjust console size appropriately

                    // TODO print screen

                    InputOptionBuilder.Create("Action:")
                        // TODO add options
                        // draw from deck (3 cards at a time)
                        //   enter
                        // select card
                        //   1 thru 7 for piles,
                        //   (use something for final piles)
                        //   (use something for top card in hand)
                        .Request();
                    // TODO
                }
                break;
        }
    }

    enum Stage
    {
        MainMenu,
        GameSetup,
        Game,
    }

    public sealed class Deck
    {
        public const int DECKSIZE = 52; // TODO make private?
        public const int SUITSIZE = 13; // TODO make private?

        private readonly List<Card> cards = new List<Card>();

        private Card GetCard(int index)
        {
            if (this.cards.Count > 0)
            {
                return this.cards[index];
            }
            else
            {
                return null;
            }
        }

        public Card GetFirstCard() { return this.GetCard(0); }
        public Card GetLastCard() { return this.GetCard(this.cards.Count - 1); }

        public void DealTo(Deck deck)
        {
            if (this.cards.Count > 0)
            {
                deck.cards.Add(this.cards[0]);
                this.cards.RemoveAt(0);
            }
        }

        public static Deck CreateShuffledDeck()
        {
            string[] suits = new String[] { "Clubs", "Diamonds", "Hearts", "Spades" };
            Deck deckTemp = new Deck();
            Deck deck = new Deck();

            for (int i = 0; i < DECKSIZE; i++)
            {
                deckTemp.cards.Add(new Card(suits[i / SUITSIZE], (i % SUITSIZE) + 1));
            }

            // Take all cards out of 'deckTemp' at random order
            for (int i = 0; i < DECKSIZE; i++)
            {
                int r = Util.Random.Next(deckTemp.cards.Count);
                deck.cards.Add(deckTemp.cards[r]);
                deckTemp.cards.RemoveAt(r);
            }

            return deck;
        }

        public sealed override string ToString()
        {
            bool first = true;
            string s = "";

            foreach (Card card in this.cards)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    s += " ";
                }

                s += card.ToString();
            }

            return s;
        }
    }

    public sealed class Card
    {
        private readonly string suit;
        private readonly int value;

        public Card(string suit, int value)
        {
            this.suit = suit;
            this.value = value;
        }

        private string GetValueIcon()
        {
            switch (this.value)
            {
                case 11: return " J";
                case 12: return " Q";
                case 13: return " K";
                default: return string.Format("{0,2}", value);
            }
        }

        public override string ToString() { return " " + this.GetValueIcon() + " of " + this.suit; }
    }
}

public class Vector2
{
    public static readonly Vector2 Up = new Vector2(0, 1);
    public static readonly Vector2 Left = new Vector2(-1, 0);
    public static readonly Vector2 Right = new Vector2(1, 0);
    public static readonly Vector2 Down = new Vector2(0, -1);

    public int x = 0;
    public int y = 0;

    public Vector2() { }

    public Vector2(int size) : this(size, size) { }

    public Vector2(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public override int GetHashCode() { return (this.x * this.y).GetHashCode(); }

    public override bool Equals(object obj) { return obj is Vector2 && this == (Vector2)obj; }

    public static Vector2 operator +(Vector2 vecA, Vector2 vecB) { return new Vector2(vecA.x + vecB.x, vecA.y + vecB.y); }

    public static Vector2 operator -(Vector2 vecA, Vector2 vecB) { return new Vector2(vecA.x - vecB.x, vecA.y - vecB.y); }

    public static Vector2 operator *(Vector2 vec, int i) { return new Vector2(vec.x * i, vec.y * i); }

    public static Vector2 operator /(Vector2 vec, int i) { return new Vector2(vec.x / i, vec.y / i); }

    public static bool operator ==(Vector2 vecA, Vector2 vecB) { return vecA.x == vecB.x && vecA.y == vecB.y; }

    public static bool operator !=(Vector2 vecA, Vector2 vecB) { return !(vecA == vecB); }

    public sealed override string ToString() { return string.Format("({0}, {1})", this.x, this.y); }
}